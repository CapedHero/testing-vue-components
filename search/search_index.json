{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started How to create a new test suite? Write one minimal test that successfully renders the tested component. The test should not output any errors or warnings. The test should have a minimal setup and minimal input. A good verification is that you cannot remove any line because the test will immediately fail or start outputting warnings or errors. Once you have such a minimal test, copy it and adjust it for specific test cases. What to test? Rendering Test whether key headers, texts, errors, etc., are rendered by the component. Test every logical branch, including each v-if , v-show , and v-for (the latter with an empty and at least two-elements collection). Jest coverage report will be your best friend here. It clearly shows which parts of the component were not rendered by the tests, which will help you find the next test case. Interaction Test clicks, swipes, or any other user interaction with the component. Events Handling Test if the component properly handles the events emitted by its children components. What about testing logic? Logic should be tested as part of above-mentioned groups of tests, e.g.: If the logic results in changes to the rendered component, then test whether specific outputs were rendered. If the logic results in side effects, then stub or mock the called functions and test whether the expected calls were made. Usually, it is a part of the \u201cInteraction\u201d tests. An example would be whether a proper API call was made after the form was submitted. Still, sometimes you will just have to be creative. In such cases, try to extend the test suite in a readable, logical manner. Consider this example. You call some important business logic with side effects during component mounting. This could warrant a couple of tests with mocks in their own section of \u201cMounting\u201d. Moreover, sometimes it is worth extracting the logic to a separate JS module in order to test it independently of any component rendering. This is especially applicable when the logic is reusable. Similarly, it could be a good idea to extract the logic when there are numerous simple cases that are straightforward to test on their own, while testing in a fully-rendered component would be wasteful and less readable.","title":"Getting Started"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#how-to-create-a-new-test-suite","text":"Write one minimal test that successfully renders the tested component. The test should not output any errors or warnings. The test should have a minimal setup and minimal input. A good verification is that you cannot remove any line because the test will immediately fail or start outputting warnings or errors. Once you have such a minimal test, copy it and adjust it for specific test cases.","title":"How to create a new test suite?"},{"location":"#what-to-test","text":"Rendering Test whether key headers, texts, errors, etc., are rendered by the component. Test every logical branch, including each v-if , v-show , and v-for (the latter with an empty and at least two-elements collection). Jest coverage report will be your best friend here. It clearly shows which parts of the component were not rendered by the tests, which will help you find the next test case. Interaction Test clicks, swipes, or any other user interaction with the component. Events Handling Test if the component properly handles the events emitted by its children components.","title":"What to test?"},{"location":"#what-about-testing-logic","text":"Logic should be tested as part of above-mentioned groups of tests, e.g.: If the logic results in changes to the rendered component, then test whether specific outputs were rendered. If the logic results in side effects, then stub or mock the called functions and test whether the expected calls were made. Usually, it is a part of the \u201cInteraction\u201d tests. An example would be whether a proper API call was made after the form was submitted. Still, sometimes you will just have to be creative. In such cases, try to extend the test suite in a readable, logical manner. Consider this example. You call some important business logic with side effects during component mounting. This could warrant a couple of tests with mocks in their own section of \u201cMounting\u201d. Moreover, sometimes it is worth extracting the logic to a separate JS module in order to test it independently of any component rendering. This is especially applicable when the logic is reusable. Similarly, it could be a good idea to extract the logic when there are numerous simple cases that are straightforward to test on their own, while testing in a fully-rendered component would be wasteful and less readable.","title":"What about testing logic?"},{"location":"best-practices/","text":"Best Practices Prefer mount to shallowMount https://v1.test-utils.vuejs.org/guides/common-tips.html#shallow-mounting Notice that using shallowMount will make the component under testing different from the component you run in your application \u2013 some of its parts won't be rendered! This is why it is not the suggested way of testing components unless you face performance issues or need to simplify test arrangements. https://github.com/goldbergyoni/javascript-testing-best-practices#-\ufe0f-33-whenever-possible-test-with-a-realistic-and-fully-rendered-component Whenever reasonably sized, test your component from outside like your users do, fully render the UI, act on it and assert that the rendered UI behaves as expected. Avoid all sort of mocking, partial and shallow rendering - this approach might result in untrapped bugs due to lack of details and harden the maintenance as the tests mess with the internals. Finding the tested element Use data-role attribute e.g. <AccountPreview data-role=\"account-preview\"> This means that the above example you would find via: const accountPreview = wrapper . find ( '[data-role=\"account-preview\"]' ) data-role is independent of the implementation details like component name, HTML tag, CSS classes, or JavaScript ID. Thus, it offers a robust, test-specific attribute. As a bonus, data-role adds extra clarity regarding what is the purpose of a given component or HTML element. Basic Test Suite Structure /*************/ /* VUE SETUP */ /*************/ // Configure Vue for testing. // Mostly, it's about properly wiring localVue instance. /***************/ /* TEST VALUES */ /***************/ // Put here ALL of the values used in the tests. This will provide additional // information via clear constants names, as well as get rid entirely of magical // numbers and similar. const testCountry = { code : 'UK' , currency : '\u00a3' , currencyCode : 'GBP' , name : 'United Kingdom' , } const testEmail = 'test@email.com' const testId = 123 /***************/ /* MOCKS/STUBS */ /***************/ // Place all but the simplest mocks and stubs in this separate section. // In result, those test doubles will have a clear interface and will // not \"pollute\" the tests bodies. function createSentryMock () { // ...logic return mock } class axiosStub { // ...logic } /************/ /* WRAPPERS */ /************/ // The goal of this section is to extract the tested component // creation logic, so it has a clear interface and does not // \"pollute\" the tests bodies. async function createFoo () { return await mount ( 'Foo' ) } async function createEmptyFoo () { return await mount ( 'Foo' , { propsData : { isEmpty : true }}) } /*********/ /* TESTS */ /*********/ describe ( 'Test group 1' , () => { test ( 'Test 1' , () => { // ...logic }) }) Basic test structure It is recommended to follow ARRANGE-ACT-ASSERT pattern. https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/ describe ( 'Test group 1' , () => { test ( 'Test 1' , () => { // Arrange // // Here create a wrapper, configure mocks, extract nested values, etc. // Pre-Assert // // This section is quite unorthodox. It can come useful when we want to // ensure that acting on a component really changes something in the // DOM. For instance, if we want to test if a modal appears after clicking // a button, it might wise to test here if the modal wasn't already rendered // in the first place. // Act // // Here we act on the component. Usually, this means triggering an action. // Note that this section might not be used at all, as there would be // no specific action to test. This happens quite often when testing // the rendering. // Assert // // Here come all of the jest expect statements with which we assert // that the component is working as intended. }) })","title":"Best Practices"},{"location":"best-practices/#best-practices","text":"","title":"Best Practices"},{"location":"best-practices/#prefer-mount-to-shallowmount","text":"https://v1.test-utils.vuejs.org/guides/common-tips.html#shallow-mounting Notice that using shallowMount will make the component under testing different from the component you run in your application \u2013 some of its parts won't be rendered! This is why it is not the suggested way of testing components unless you face performance issues or need to simplify test arrangements. https://github.com/goldbergyoni/javascript-testing-best-practices#-\ufe0f-33-whenever-possible-test-with-a-realistic-and-fully-rendered-component Whenever reasonably sized, test your component from outside like your users do, fully render the UI, act on it and assert that the rendered UI behaves as expected. Avoid all sort of mocking, partial and shallow rendering - this approach might result in untrapped bugs due to lack of details and harden the maintenance as the tests mess with the internals.","title":"Prefer mount to shallowMount"},{"location":"best-practices/#finding-the-tested-element","text":"Use data-role attribute e.g. <AccountPreview data-role=\"account-preview\"> This means that the above example you would find via: const accountPreview = wrapper . find ( '[data-role=\"account-preview\"]' ) data-role is independent of the implementation details like component name, HTML tag, CSS classes, or JavaScript ID. Thus, it offers a robust, test-specific attribute. As a bonus, data-role adds extra clarity regarding what is the purpose of a given component or HTML element.","title":"Finding the tested element"},{"location":"best-practices/#basic-test-suite-structure","text":"/*************/ /* VUE SETUP */ /*************/ // Configure Vue for testing. // Mostly, it's about properly wiring localVue instance. /***************/ /* TEST VALUES */ /***************/ // Put here ALL of the values used in the tests. This will provide additional // information via clear constants names, as well as get rid entirely of magical // numbers and similar. const testCountry = { code : 'UK' , currency : '\u00a3' , currencyCode : 'GBP' , name : 'United Kingdom' , } const testEmail = 'test@email.com' const testId = 123 /***************/ /* MOCKS/STUBS */ /***************/ // Place all but the simplest mocks and stubs in this separate section. // In result, those test doubles will have a clear interface and will // not \"pollute\" the tests bodies. function createSentryMock () { // ...logic return mock } class axiosStub { // ...logic } /************/ /* WRAPPERS */ /************/ // The goal of this section is to extract the tested component // creation logic, so it has a clear interface and does not // \"pollute\" the tests bodies. async function createFoo () { return await mount ( 'Foo' ) } async function createEmptyFoo () { return await mount ( 'Foo' , { propsData : { isEmpty : true }}) } /*********/ /* TESTS */ /*********/ describe ( 'Test group 1' , () => { test ( 'Test 1' , () => { // ...logic }) })","title":"Basic Test Suite Structure"},{"location":"best-practices/#basic-test-structure","text":"It is recommended to follow ARRANGE-ACT-ASSERT pattern. https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/ describe ( 'Test group 1' , () => { test ( 'Test 1' , () => { // Arrange // // Here create a wrapper, configure mocks, extract nested values, etc. // Pre-Assert // // This section is quite unorthodox. It can come useful when we want to // ensure that acting on a component really changes something in the // DOM. For instance, if we want to test if a modal appears after clicking // a button, it might wise to test here if the modal wasn't already rendered // in the first place. // Act // // Here we act on the component. Usually, this means triggering an action. // Note that this section might not be used at all, as there would be // no specific action to test. This happens quite often when testing // the rendering. // Assert // // Here come all of the jest expect statements with which we assert // that the component is working as intended. }) })","title":"Basic test structure"},{"location":"jest-snippets-book/","text":"Jest Snippets Book Registering 3rd party components, plugins, mixins, directives, etc. import { createLocalVue , mount } from '@vue/test-utils' // https://v1.test-utils.vuejs.org/api/createlocalvue.html#createlocalvue const localVue = createLocalVue () localVue . use ( '*3RD PARTY MODULE*' ) s test ( 'test' , async () => { const wrapper = await mount ( Foo , { localVue }) }) Special case: Vuetify // Globa Vuetify registration should be called once in test/setup.js Vue . use ( Vuetify ) const localVue = createLocalVue () localVue . use ( Vuetify ) Special case: Error in v-on handler: \"TypeError: Cannot read properties of undefined (reading '_transitionClasses')\u201d const wrapper = await mount ( 'Foo' , { sync : false }) Note Is this stil necessary after using the latest vue-test-utils ? Injecting props and data to tested component async function createComponentFoo () { return await mount ( Foo , { propsData : { bar : 'bar' , }, data : () => ({ baz : 'baz' , }), }, ) } Stubbing child components It\u2019s especially useful for stubbing Font Awesome or specific Vuetify components. // https://v1.test-utils.vuejs.org/api/options.html#stubs async function createComponentFoo () { const wrapper = await mount ( Foo , { stubs : { fa : true , BaseButton : true , }, }, ) return wrapper } Finding DOM elements const wrapper = await mount ( 'Foo' ) const oneEl = wrapper . find ( '*VALID-SELECTOR*' ) const allEls = wrapper . findAll ( '*VALID-SELECTOR*' ) const firstElFromAllEls = allEls . at ( 0 ) Settings form values const inputFoo = wrapper . find ( '[data-role=\"form-input-foo\"]' ) inputFoo . setValue ( 'foo' ) Trigger native DOM event wrapper . trigger ( '*DOM-EVENT*' ) wrapper . trigger ( 'click' ) Trigger custom events wrapper . vm . $emit ( '*CUSTOM-EVENT*' ) wrapper . vm . $emit ( 'add-account' ) Waiting for DOM to re-rerender If the tested component does not show what you expect, it might be possible that you must explicitly wait for the DOM to re-rerender. This is especially the case after triggering clicks, popping modals/alerts/errors, or with larger component when it might take a couple rendering cycles for the DOM to fully render. In such cases, first await the method that you mutated the state with, e.g.: await wrapper . trigger ( 'click' ) Attention mount is also awaitable! As a result, always call await mount(Foo) . If this doesn't work, try to explicitly wait until Vue.js has finished updating the DOM after a data change: await Vue . nextTick () Sometimes it requires more than one rendering cycle to fully render the state you want to test. In such cases, call: for ( let i = 0 ; i < 3 ; i ++ ) { await Vue . nextTick () } // In my personal experience, it never needs more than 3 rendering cycles. Most useful mocks Mocking $router (or any other dollar attribute like $env) async function createComponentFoo () { const routerPushMock = jest . fn () const testRouter = { push : routerPushMock } const wrapper = await mount ( Foo , { localVue , mocks : { $router : testRouter }, }, ) return { wrapper , routerPushMock } } Mocking Vuex store async function createComponentFoo () { const setBarMock = jest . fn () const store = new Vuex . Store ({ actions : { 'module1/setBar' : setBarMock , }, getters : { 'module1/getBaz' : () => 'baz' , }, }) const wrapper = await mount ( Foo , { localVue , mocks : { $router : testRouter }, }, ) return { wrapper , setBarMock } } Mocking fetch describe ( 'Test group 1' , () => { beforeEach (() => { fetchMock . resetMocks () }) test ( 'Test 1' , () => { // Logic that is using fetch expect ( fetch . mock . calls [ 0 ][ 0 ]). toEqual ( 'expectedUrl' ) expect ( fetch . mock . calls [ 0 ][ 1 ]. method ). toEqual ( 'GET' ) expect ( fetch . mock . calls [ 0 ][ 1 ]. body ). toEqual ( JSON . stringify ( expectedBody )) }) }) Mock \u201cerror\u201d response from axios function createAxiosGetMockThrowingError400 () { const axiosGetMockError = new Error ( 'Test Axios GET 400 Error' ) axiosGetMockError . statusCode = 400 return jest . fn (). mockImplementation (() => Promise . reject ( axiosGetMockError )) } Spying on method calls const methodSpy = jest . spyOn ( Foo . methods , 'methodToSpyOn' ) Testing with expect Most useful expect validators // https://jestjs.io/docs/expect expect ( string ). toContain ( text ) expect ( string ). toMatch ( textPattern ) expect ( clientId ). toEqual ( 123 ) expect ( client ). toEqual ({ foo : 'foo' }) expect ( isShown ). toBe ( true ) expect ( array ). toHaveLength ( 3 ) expect ( spy ). toHaveBeenCalled () expect ( jestMock . mock . calls [ callNum ][ callArgIndex ]). toEqual ({ expectedPayload }) // Negation expect ( clientId ). not . toEqual ( 456 ) Common expect formulas // Check if el exists expect ( wrapper . exists ()). toBe ( true ) // Check if el text matches regex pattern expect ( wrapper . text ()). toMatch ( textPattern ) // Check if el is disabled expect ( !! wrapper . attributes ( 'disabled' )). toBe ( true ) // Check if el emitted events const targetEvents = wrapper . emitted ()[ 'eventName' ] const targetEvent = targetEvents . length ? targetEvents [ 0 ] : null expect ( !! event ). toBe ( true ) const actualEventPayload = event [ 0 ] const expectedEventPayload = { foo : 'foo' } expect ( actualEventPayload ). toEqual ( expectedEventPayload ) Test parametrization https://jestjs.io/docs/api#testeachtablename-fn-timeout test . each ` a | b | expected ${ 1 } | ${ 1 } | ${ 2 } ${ 1 } | ${ 2 } | ${ 3 } ${ 2 } | ${ 1 } | ${ 3 } ` ( 'returns $expected when $a is added $b' , ({ a , b , expected }) => { expect ( a + b ). toBe ( expected ); }); test . each ([ [ 1 , 1 , 2 ], [ 1 , 2 , 3 ], [ 2 , 1 , 3 ], ])( '.add(%i, %i)' , ( a , b , expected ) => { expect ( a + b ). toBe ( expected ); }); Master Template import VTooltip from 'v-tooltip' import Vuetify from 'vuetify' import Vuex from 'vuex' import { createLocalVue , mount } from '@vue/test-utils' /*************/ /* VUE SETUP */ /*************/ const localVue = createLocalVue () localVue . use ( Vuetify ) localVue . use ( Vuex ) localVue . use ( VTooltip ) /***************/ /* TEST VALUES */ /***************/ /*********/ /* MOCKS */ /*********/ /************/ /* WRAPPERS */ /************/ async function createFoo () { return await mount ( Foo , { localVue , propsData : { bar : 'bar' , }, data : () => ({ baz : 'baz' , }), stubs : { fa : true }, }, ) } /*********/ /* TESTS */ /*********/ describe ( 'Test group 1' , () => { test ( 'Test 1' , async () => { // Arrange const wrapper = await createFoo () // Pre-Assert // Act // Assert }) })","title":"Jest Snippets Book"},{"location":"jest-snippets-book/#jest-snippets-book","text":"","title":"Jest Snippets Book"},{"location":"jest-snippets-book/#registering-3rd-party-components-plugins-mixins-directives-etc","text":"import { createLocalVue , mount } from '@vue/test-utils' // https://v1.test-utils.vuejs.org/api/createlocalvue.html#createlocalvue const localVue = createLocalVue () localVue . use ( '*3RD PARTY MODULE*' ) s test ( 'test' , async () => { const wrapper = await mount ( Foo , { localVue }) })","title":"Registering 3rd party components, plugins, mixins, directives, etc."},{"location":"jest-snippets-book/#special-case-vuetify","text":"// Globa Vuetify registration should be called once in test/setup.js Vue . use ( Vuetify ) const localVue = createLocalVue () localVue . use ( Vuetify )","title":"Special case: Vuetify"},{"location":"jest-snippets-book/#special-case-error-in-v-on-handler-typeerror-cannot-read-properties-of-undefined-reading-_transitionclasses","text":"const wrapper = await mount ( 'Foo' , { sync : false }) Note Is this stil necessary after using the latest vue-test-utils ?","title":"Special case: Error in v-on handler: \"TypeError: Cannot read properties of undefined (reading '_transitionClasses')\u201d"},{"location":"jest-snippets-book/#injecting-props-and-data-to-tested-component","text":"async function createComponentFoo () { return await mount ( Foo , { propsData : { bar : 'bar' , }, data : () => ({ baz : 'baz' , }), }, ) }","title":"Injecting props and data to tested component"},{"location":"jest-snippets-book/#stubbing-child-components","text":"It\u2019s especially useful for stubbing Font Awesome or specific Vuetify components. // https://v1.test-utils.vuejs.org/api/options.html#stubs async function createComponentFoo () { const wrapper = await mount ( Foo , { stubs : { fa : true , BaseButton : true , }, }, ) return wrapper }","title":"Stubbing child components"},{"location":"jest-snippets-book/#finding-dom-elements","text":"const wrapper = await mount ( 'Foo' ) const oneEl = wrapper . find ( '*VALID-SELECTOR*' ) const allEls = wrapper . findAll ( '*VALID-SELECTOR*' ) const firstElFromAllEls = allEls . at ( 0 )","title":"Finding DOM elements"},{"location":"jest-snippets-book/#settings-form-values","text":"const inputFoo = wrapper . find ( '[data-role=\"form-input-foo\"]' ) inputFoo . setValue ( 'foo' )","title":"Settings form values"},{"location":"jest-snippets-book/#trigger-native-dom-event","text":"wrapper . trigger ( '*DOM-EVENT*' ) wrapper . trigger ( 'click' )","title":"Trigger native DOM event"},{"location":"jest-snippets-book/#trigger-custom-events","text":"wrapper . vm . $emit ( '*CUSTOM-EVENT*' ) wrapper . vm . $emit ( 'add-account' )","title":"Trigger custom events"},{"location":"jest-snippets-book/#waiting-for-dom-to-re-rerender","text":"If the tested component does not show what you expect, it might be possible that you must explicitly wait for the DOM to re-rerender. This is especially the case after triggering clicks, popping modals/alerts/errors, or with larger component when it might take a couple rendering cycles for the DOM to fully render. In such cases, first await the method that you mutated the state with, e.g.: await wrapper . trigger ( 'click' ) Attention mount is also awaitable! As a result, always call await mount(Foo) . If this doesn't work, try to explicitly wait until Vue.js has finished updating the DOM after a data change: await Vue . nextTick () Sometimes it requires more than one rendering cycle to fully render the state you want to test. In such cases, call: for ( let i = 0 ; i < 3 ; i ++ ) { await Vue . nextTick () } // In my personal experience, it never needs more than 3 rendering cycles.","title":"Waiting for DOM to re-rerender"},{"location":"jest-snippets-book/#most-useful-mocks","text":"","title":"Most useful mocks"},{"location":"jest-snippets-book/#mocking-router-or-any-other-dollar-attribute-like-env","text":"async function createComponentFoo () { const routerPushMock = jest . fn () const testRouter = { push : routerPushMock } const wrapper = await mount ( Foo , { localVue , mocks : { $router : testRouter }, }, ) return { wrapper , routerPushMock } }","title":"Mocking $router (or any other dollar attribute like $env)"},{"location":"jest-snippets-book/#mocking-vuex-store","text":"async function createComponentFoo () { const setBarMock = jest . fn () const store = new Vuex . Store ({ actions : { 'module1/setBar' : setBarMock , }, getters : { 'module1/getBaz' : () => 'baz' , }, }) const wrapper = await mount ( Foo , { localVue , mocks : { $router : testRouter }, }, ) return { wrapper , setBarMock } }","title":"Mocking Vuex store"},{"location":"jest-snippets-book/#mocking-fetch","text":"describe ( 'Test group 1' , () => { beforeEach (() => { fetchMock . resetMocks () }) test ( 'Test 1' , () => { // Logic that is using fetch expect ( fetch . mock . calls [ 0 ][ 0 ]). toEqual ( 'expectedUrl' ) expect ( fetch . mock . calls [ 0 ][ 1 ]. method ). toEqual ( 'GET' ) expect ( fetch . mock . calls [ 0 ][ 1 ]. body ). toEqual ( JSON . stringify ( expectedBody )) }) })","title":"Mocking fetch"},{"location":"jest-snippets-book/#mock-error-response-from-axios","text":"function createAxiosGetMockThrowingError400 () { const axiosGetMockError = new Error ( 'Test Axios GET 400 Error' ) axiosGetMockError . statusCode = 400 return jest . fn (). mockImplementation (() => Promise . reject ( axiosGetMockError )) }","title":"Mock \u201cerror\u201d response from axios"},{"location":"jest-snippets-book/#spying-on-method-calls","text":"const methodSpy = jest . spyOn ( Foo . methods , 'methodToSpyOn' )","title":"Spying on method calls"},{"location":"jest-snippets-book/#testing-with-expect","text":"","title":"Testing with expect"},{"location":"jest-snippets-book/#most-useful-expect-validators","text":"// https://jestjs.io/docs/expect expect ( string ). toContain ( text ) expect ( string ). toMatch ( textPattern ) expect ( clientId ). toEqual ( 123 ) expect ( client ). toEqual ({ foo : 'foo' }) expect ( isShown ). toBe ( true ) expect ( array ). toHaveLength ( 3 ) expect ( spy ). toHaveBeenCalled () expect ( jestMock . mock . calls [ callNum ][ callArgIndex ]). toEqual ({ expectedPayload }) // Negation expect ( clientId ). not . toEqual ( 456 )","title":"Most useful expect validators"},{"location":"jest-snippets-book/#common-expect-formulas","text":"// Check if el exists expect ( wrapper . exists ()). toBe ( true ) // Check if el text matches regex pattern expect ( wrapper . text ()). toMatch ( textPattern ) // Check if el is disabled expect ( !! wrapper . attributes ( 'disabled' )). toBe ( true ) // Check if el emitted events const targetEvents = wrapper . emitted ()[ 'eventName' ] const targetEvent = targetEvents . length ? targetEvents [ 0 ] : null expect ( !! event ). toBe ( true ) const actualEventPayload = event [ 0 ] const expectedEventPayload = { foo : 'foo' } expect ( actualEventPayload ). toEqual ( expectedEventPayload )","title":"Common expect formulas"},{"location":"jest-snippets-book/#test-parametrization","text":"https://jestjs.io/docs/api#testeachtablename-fn-timeout test . each ` a | b | expected ${ 1 } | ${ 1 } | ${ 2 } ${ 1 } | ${ 2 } | ${ 3 } ${ 2 } | ${ 1 } | ${ 3 } ` ( 'returns $expected when $a is added $b' , ({ a , b , expected }) => { expect ( a + b ). toBe ( expected ); }); test . each ([ [ 1 , 1 , 2 ], [ 1 , 2 , 3 ], [ 2 , 1 , 3 ], ])( '.add(%i, %i)' , ( a , b , expected ) => { expect ( a + b ). toBe ( expected ); });","title":"Test parametrization"},{"location":"jest-snippets-book/#master-template","text":"import VTooltip from 'v-tooltip' import Vuetify from 'vuetify' import Vuex from 'vuex' import { createLocalVue , mount } from '@vue/test-utils' /*************/ /* VUE SETUP */ /*************/ const localVue = createLocalVue () localVue . use ( Vuetify ) localVue . use ( Vuex ) localVue . use ( VTooltip ) /***************/ /* TEST VALUES */ /***************/ /*********/ /* MOCKS */ /*********/ /************/ /* WRAPPERS */ /************/ async function createFoo () { return await mount ( Foo , { localVue , propsData : { bar : 'bar' , }, data : () => ({ baz : 'baz' , }), stubs : { fa : true }, }, ) } /*********/ /* TESTS */ /*********/ describe ( 'Test group 1' , () => { test ( 'Test 1' , async () => { // Arrange const wrapper = await createFoo () // Pre-Assert // Act // Assert }) })","title":"Master Template"}]}